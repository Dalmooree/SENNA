utils::globalVariables(
  c("X1",
    "X2",
    "adj.p",
    "Coefficients",
    "Gene",
    "p",
    "distance",
    "box",
    "gwei",
    "region",
    "regn",
    "index",
    "x",
    "y",
    "CLS",
    "bat",
    "Bin",
    "Coef",
    "rn",
    "gcount",
    "interval",
    "app_dat",
    "K",
    "bin")
)



#' SENNA: S4 class for user-interactive spatial analysis
#'
#' Defines the S4 class 'SENNA' for user-interactive spatial analysis.
#'
#' @importFrom methods setClass
#' @slot Gene Gene count data
#' @slot Coord Spatial coordinate data
#' @slot CurveAxis Curve axis function
#' @exportClass SENNA

setClass(
  "SENNA",
  slots = list(
    Gene = "list",
    Coord = "list",
    CurveAxis = "list")
)



#' mSENNA: S4 class for multi-SENNA approach
#'
#' Defines the S4 class 'mSENNA' for handling multiple SENNA objects.
#'
#' @importFrom methods setClass
#'
#' @slot SENNA A list of SENNA objects
#' @slot msR A report object for multi-SENNA analysis
#' @exportClass mSENNA

setClass(
  "mSENNA",
  slots = list(
    SENNA = "ANY",
    msR = "ANY")
)



#' msR: S4 class for the output report of multi-SENNA analysis
#'
#' Defines the S4 'msR' class, an output object for multi-SENNA analysis.
#'
#' @importFrom methods setClass
#'
#' @slot Report A data frame containing the analysis report
#' @slot Variable_gene A list of two character vectors storing significant genes with increasing and decreasing expression, respectively
#' @slot Filtered_gene A character vector of genes filtered out due to singularity
#' @exportClass msR
#'

setClass(
  "msR",
  slots = list(
    Report = "data.frame",
    Variable_gene = "list",
    Filtered_gene = "ANY")
)



#' sktS: S4 class for visualizing SENNA object
#'
#' Defines the S4 class 'sktS' (Sketch SENNA).
#'
#' @importFrom methods setClass
#'
#' @slot sketch A data frame generated by `SketchPatterns()`
#' @slot label A character vector of gene names
#' @exportClass sktS


setClass(
  "sktS",
  slots = list(sketch = "data.frame",
               label = "character")
)



#' simplesktS: S4 class for visualizing SENNA object
#'
#' Defines the S4 class 'simplesktS' (Sketch SENNA).
#'
#' @importFrom methods setClass
#'
#' @slot sketch A matrix generated by `SketchPatterns()`
#' @slot label A character vector of gene names
#' @slot n_spots An integer vector indicating the number of spots for each value
#' @exportClass simplesktS

setClass(
  "simplesktS",
  slots = list(sketch = "matrix",
               label = "character",
               n_spots = "integer")
)



#' Create SENNA object from Visium dataset
#'
#' Converts a 10X Visium `Seurat` object into a `SENNA` object.
#'
#' @importFrom SeuratObject VariableFeatures
#' @importFrom SeuratObject Features
#' @importFrom SeuratObject FetchData
#' @importFrom SeuratObject DefaultAssay
#' @importFrom magrittr %>%
#' @importFrom methods new
#' @importClassesFrom Seurat Seurat
#' @param InputObj Input Seurat object. Must be normalized (e.g., via SCTransform).
#' @param assay Assay name
#' @param slice_name Slice name of the input Seurat object (must match exactly)
#' @param all_genes Logical. If TRUE, uses all features instead of only variable ones
#' @param annotation Logical. If TRUE, includes cell annotation in the output object
#' @return A `SENNA` object
#' @export

SENNA_Visium <- function(InputObj,
                         assay = NULL,
                         slice_name,
                         all_genes = FALSE,
                         annotation = FALSE){
  if(!is.null(assay)) SeuratObject::DefaultAssay(InputObj) <- assay
  if(all_genes){
    feat <- SeuratObject::Features(InputObj)
  } else{
    feat <- SeuratObject::VariableFeatures(InputObj)
  }
  
  gene <- suppressWarnings(Seurat::FetchData(InputObj,
                                             vars = feat,
                                             layer = "scale.data"))

  coord <- SeuratObject::GetTissueCoordinates(InputObj, image = NULL)[ ,2:1]
  colnames(coord) <- c("X1", "X2")
  ary <- coord
  coord <- dplyr::mutate(coord, X2 = -X2)
  scale_factor <- max(
    max(coord$X2) - min(coord$X2),
    max(coord$X1) - min(coord$X1))
  coord <- dplyr::mutate(
    coord,
    X1 = (X1 - min(X1)) / scale_factor,
    X2 = (X2 - min(X2)) / scale_factor)

  if(annotation){
    label <- InputObj@active.ident
    res = methods::new("SENNA",
                       Gene = list(Spatial = gene,
                                   Reference = list(
                                     Annotation = label),
                                   source = "Visium"),
                       Coord = list(Spatial = coord,
                                    iary = ary),
                       CurveAxis = list(type = NA))
  } else{
    res <- methods::new("SENNA",
                       Gene = list(Spatial = gene,
                                   Info = NULL,
                                   source = "Visium"),
                       Coord = list(Spatial = coord,
                                    iary = ary),
                       CurveAxis = list(type = NA))
  }

  return(res)
}



#' Create SENNA object from Xenium dataset
#'
#' Converts a 10X Xenium `Seurat` object into a `SENNA` object.
#'
#' @importFrom SeuratObject VariableFeatures
#' @importFrom SeuratObject FetchData
#' @importFrom SeuratObject DefaultAssay
#' @importFrom magrittr %>%
#' @importFrom methods new
#' @importClassesFrom Seurat Seurat
#' @param InputObj Input Seurat object. Must be normalized (e.g., via SCTransform).
#' @param assay Assay name
#' @param fov_name FOV name of the input Seurat object (must match exactly)
#' @param annotation Logical. If TRUE, includes cell annotation in the output object
#' @return A `SENNA` object
#' @export

SENNA_Xenium <- function(InputObj,
                         assay = NULL,
                         fov_name,
                         annotation = FALSE) {
  if(!is.null(assay)) SeuratObject::DefaultAssay(InputObj) <- assay
  feat <- SeuratObject::VariableFeatures(InputObj)
  gene <- suppressWarnings(Seurat::FetchData(InputObj,
                                             vars = feat,
                                             layer = "scale.data"))

  centroid <- Seurat::GetTissueCoordinates(InputObj, image = fov_name)
  centroid <- dplyr::mutate(centroid,
                            X1 = x,
                            X2 = y)
  centroid <- dplyr::mutate(centroid, X2 = -X2)
  scale_factor <- max(
    max(centroid$X2) - min(centroid$X2),
    max(centroid$X1) - min(centroid$X1))
  centroid <- dplyr::mutate(
    centroid,
    X1 = (X1 - min(X1)) / scale_factor,
    X2 = (X2 - min(X2)) / scale_factor)

  rownames(centroid) <- centroid$cell
  centroid <- dplyr::select(centroid, X1, X2)
  
  if(annotation){
    label <- InputObj@active.ident
    res <- methods::new("SENNA",
                       Gene = list(Spatial = gene,
                                   Reference = list(
                                     Annotation = label),
                                   source = "Xenium"),
                       Coord = list(Spatial = centroid),
                       CurveAxis = list(type = NA))
  } else{
    res <- methods::new("SENNA",
                        Gene = list(Spatial = gene,
                                    Info = NULL,
                                    source = "Xenium"),
                        Coord = list(Spatial = centroid),
                        CurveAxis = list(type = NA))
  }
  return(res)
}





#' Create SENNA object from Nanostring CosMx dataset
#'
#' Converts a Nanostring CosMx `Seurat` object into a `SENNA` object.
#'
#' @importFrom SeuratObject VariableFeatures
#' @importFrom SeuratObject FetchData
#' @importFrom SeuratObject DefaultAssay
#' @importFrom magrittr %>%
#' @importFrom methods new
#' @importClassesFrom Seurat Seurat
#' @param InputObj Input Seurat object. Must be normalized (e.g., via SCTransform).
#' @param assay Assay name
#' @param fov_name FOV name of the input Seurat object (must match exactly)
#' @param annotation Logical. If TRUE, includes cell annotation in the output object
#' @return A `SENNA` object
#' @export

SENNA_CosMx <- function(InputObj,
                        assay = NULL,
                        fov_name,
                        annotation = FALSE) {
  if(!is.null(assay)) SeuratObject::DefaultAssay(InputObj) <- assay
  feat <- SeuratObject::VariableFeatures(InputObj)
  gene <- suppressWarnings(Seurat::FetchData(InputObj,
                                             vars = feat,
                                             layer = "scale.data"))
  
  centroid <- Seurat::GetTissueCoordinates(InputObj, image = fov_name)
  centroid <- dplyr::mutate(centroid,
                            X1 = x,
                            X2 = y)
  scale_factor <- max(
    max(centroid$X2) - min(centroid$X2),
    max(centroid$X1) - min(centroid$X1))
  centroid <- dplyr::mutate(
    centroid,
    X1 = (X1 - min(X1)) / scale_factor,
    X2 = (X2 - min(X2)) / scale_factor)
  
  rownames(centroid) <- centroid$cell
  centroid <- dplyr::select(centroid, X1, X2)
  
  if(annotation){
    label <- InputObj@active.ident
    res <- methods::new("SENNA",
                       Gene = list(Spatial = gene,
                                   Reference = list(
                                     Annotation = label),
                                   source = "CosMx"),
                       Coord = list(Spatial = centroid),
                       CurveAxis = list(type = NA))
  } else{
    res <- methods::new("SENNA",
                        Gene = list(Spatial = gene,
                                    Info = NULL,
                                    source = "CosMx"),
                        Coord = list(Spatial = centroid),
                        CurveAxis = list(type = NA))
  }
  return(res)
}





#' Create SENNA object from CODEX dataset
#'
#' Converts a CODEX `Seurat` object into a `SENNA` object.
#'
#' @importFrom SeuratObject VariableFeatures
#' @importFrom SeuratObject FetchData
#' @importFrom SeuratObject DefaultAssay
#' @importFrom magrittr %>%
#' @importFrom methods new
#' @importClassesFrom Seurat Seurat
#' @param InputObj Input Seurat object. Must be normalized (e.g., via SCTransform).
#' @param assay Assay name
#' @param fov_name FOV name of the input Seurat object (must match exactly)
#' @param annotation Logical. If TRUE, includes cell annotation in the output object
#' @return A `SENNA` object
#' @export

SENNA_CODEX <- function(InputObj,
                        assay = NULL,
                        fov_name,
                        annotation = FALSE) {
  if(!is.null(assay)) SeuratObject::DefaultAssay(InputObj) <- assay
  feat <- SeuratObject::VariableFeatures(InputObj)
  gene <- suppressWarnings(Seurat::FetchData(InputObj,
                                             vars = feat,
                                             layer = "scale.data"))
  
  centroid <- Seurat::GetTissueCoordinates(InputObj, image = fov_name)
  centroid <- dplyr::mutate(centroid,
                            X1 = y,
                            X2 = x)
  scale_factor <- max(
    max(centroid$X2) - min(centroid$X2),
    max(centroid$X1) - min(centroid$X1))
  centroid <- dplyr::mutate(
    centroid,
    X1 = (X1 - min(X1)) / scale_factor,
    X2 = (X2 - min(X2)) / scale_factor)
  
  rownames(centroid) <- centroid$cell
  centroid <- dplyr::select(centroid, X1, X2)
  
  if(annotation){
    label <- InputObj@active.ident
    res <- methods::new("SENNA",
                        Gene = list(Spatial = gene,
                                    Reference = list(
                                      Annotation = label),
                                    source = "CODEX"),
                        Coord = list(Spatial = centroid),
                        CurveAxis = list(type = NA))
  } else{
    res <- methods::new("SENNA",
                        Gene = list(Spatial = gene,
                                    Info = NULL,
                                    source = "CODEX"),
                        Coord = list(Spatial = centroid),
                        CurveAxis = list(type = NA))
  }
  return(res)
}





#' Create mSENNA object from multiple SENNA objects
#'
#' Constructs a `mSENNA` object by combining multiple `SENNA` objects.
#'
#' @importFrom dplyr select
#' @importFrom methods new
#' @param SENNA_list A list of `SENNA` objects
#' @return A `mSENNA` object
#' @export

ConvertMultiSENNA <- function(SENNA_list){
  if("region" %in% colnames(SENNA_list[[1]]@Coord[["Spatial"]])){
    rv <- SENNA_list[[1]]@Coord[["Spatial"]]
    for(l in 2:length(SENNA_list)) {
      
    } 
  }
  
  methods::new(
    "mSENNA",
    SENNA = SENNA_list,
    msR = NULL
  )}



#' Crop SENNA
#'
#' Crops the field of view (FOV) of a `SENNA` object.
#'
#' @param senna A `SENNA` object
#' @param xlim,ylim Ranges to crop. Each should be a two-length scaled vector indicating minimum and maximum values
#' @param scaling Logical. If TRUE, performs 0–1 scaling on each coordinate
#' @return A cropped `SENNA` object
#' @export


CropSENNA <- function(senna,
                      xlim = c(0, 1),
                      ylim = c(0, 1),
                      scaling = FALSE) {
  if(!all(all(c(xlim, ylim) <= 1) & all(c(xlim, ylim) >= 0))){
    stop("'xlim' and 'ylim' should be in range 0 and 1.")
  }

  genemat <- senna@Gene[["Spatial"]]
  coordmat <- senna@Coord[["Spatial"]]

  coordmat <- subset(coordmat, subset = X1 >= min(xlim))
  coordmat <- subset(coordmat, subset = X1 <= max(xlim))
  coordmat <- subset(coordmat, subset = X2 >= min(ylim))
  coordmat <- subset(coordmat, subset = X2 <= max(ylim))

  if(scaling){
    coordmat$X1 <- (coordmat$X1 - min(coordmat$X1)) / (max(coordmat$X1) - min(coordmat$X1))
    coordmat$X2 <- (coordmat$X2 - min(coordmat$X2)) / (max(coordmat$X2) - min(coordmat$X2))
  }

  cellnames <- rownames(coordmat)
  genemat <- genemat[cellnames, ]

  senna@Gene[["Spatial"]] <- genemat
  senna@Coord[["Spatial"]] <- coordmat
  if(!is.null(senna@Gene[["Reference"]][["Annotation"]])) {
    senna@Gene[["Reference"]][["Annotation"]] <- senna@Gene[["Reference"]][["Annotation"]][names(senna@Gene[["Reference"]][["Annotation"]]) %in% rownames(senna@Gene[["Spatial"]])]
  }


  return(senna)
}



#' Creating app data
#'
#' Prepares coordinate and annotation data (and optionally image data) from a `SENNA` object for interactive app use.
#'
#' @importFrom stats complete.cases
#' @importFrom rjson fromJSON
#' @importFrom png readPNG
#' @importFrom dplyr mutate
#' @param senna A `SENNA` object
#' @param reference_value Name of reference data to visualize (e.g., annotation or numeric vector)
#' @param colorset If `reference_value` is discrete, a named vector of colors; if continuous, a palette
#' @param image_path Path to the Visium image folder. If NULL, no image will be included.
#' @param image_resolution Image resolution to use: either `"lowres"` or `"hires"`
#' @param envir Environment where `app_dat` and `app_image` will be assigned
#' @return A data frame named `app_dat` (in `envir`)
#' @export

AppDat <- function(senna,
                   reference_value = NULL,
                   colorset = NULL,
                   image_path = NULL,
                   image_resolution = c("lowres", "hires"),
                   envir = globalenv()) {
  val <- senna@Coord[["Spatial"]]
  if(!is.null(reference_value)){
    ref <- senna@Gene[["Reference"]][[reference_value]]
    if(is.numeric(ref)){
      val <- merge(x = val[, c("X1", "X2")],
                   y = ref,
                   by = "row.names",
                   all = TRUE)
      rownames(val) <- val[, 1]
      val <- val[, 2:4]
      colnames(val) <- c("X1", "X2", "CLS")

      if(!is.null(colorset)){
        assign(x = "colorset",
               value = colorset,
               pos = envir)
      } else{
        assign(x = "colorset",
               value = c("#44729d", "#b14743"),
               pos = envir)
      }
    }

    else{
      val <- merge(x = val[, c("X1", "X2")],
                   y = senna@Gene[["Reference"]][[reference_value]],
                   by = "row.names",
                   all = TRUE)
      rownames(val) <- val[, 1]
      val <- val[, 2:4]
      colnames(val) <- c("X1", "X2", "CLS")

      if(!is.null(colorset)){
        levels(val$CLS) <- colorset
        val$CLS <- as.character(val$CLS)
      }
    }}

  val <- val[stats::complete.cases(val),]
  assign(x = "app_dat",
         value = val,
         pos = envir)
  
  if(!is.null(image_path)){
    img_type <- match.arg(image_resolution)
    dpath <- image_path
    sf <- rjson::fromJSON(
      file = paste0(dpath, "scalefactors_json.json"))
    sft <- ifelse(
      img_type == "hires",
      sf$tissue_hires_scalef,
      sf$tissue_lowres_scalef
    )
    
    img <- png::readPNG(
      source = paste0(dpath, "tissue_", img_type, "_image.png"))
    idim <- dim(img)[1:2]
    img <- img[1:min(idim), 1:min(idim), , drop=FALSE]
    bgr <- grid::rasterGrob(img, interpolate = TRUE)
    
    ary <- senna@Coord[["iary"]]
    ary <- round(ary * sft)
    ary$X2 <- idim[2] - ary$X2
    
    if("CLS" %in% colnames(val)) {
      ary <- dplyr::mutate(ary,
                           CLS = val$CLS)
    }
    
    assign(x = "app_image", 
           value = list(bgr = bgr,
                        idim = idim,
                        grid = ary),
           pos = envir)
  }}



#' Run knot-picker app
#'
#' Launches the interactive Shiny app for selecting knots on a spatial map.
#'
#' @importFrom shiny runApp
#' @param path App path. Defaults to the bundled app within the package
#' @export

knot_picker <- function(path = system.file("shiny/knot_picker", package = "SENNA")) {
  if (!requireNamespace("shinythemes", quietly = TRUE) |
      !requireNamespace("markdown", quietly = TRUE)) {
    stop("Knot picker requires both `shinythemes` and `markdown` packages.")
  }

  shiny::runApp(path)
}



#' Add cell attribute
#'
#' Adds a cell attribute (e.g., annotation or metadata) to the `SENNA` object.
#'
#' @importFrom stats setNames
#' @param senna A `SENNA` object
#' @param var_name Name of the cell attribute
#' @param reference A named vector of attribute values (must match cell names)
#' @return A modified `SENNA` object with the new cell attribute added
#' @export


AddReference <- function(senna,
                         var_name,
                         reference) {
  senna@Gene[["Reference"]] <-
    c(senna@Gene[["Reference"]],
      stats::setNames(list(reference), var_name))

  names(senna@Gene[["Reference"]][[var_name]]) <- rownames(senna@Gene[["Spatial"]])

  return(senna)
}
